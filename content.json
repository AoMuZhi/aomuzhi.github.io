{"meta":{"title":"MyBlog","subtitle":null,"description":"寻找爱","author":"aogui","url":""},"pages":[{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-30T14:59:44.823Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"啊哈！算法之枚举","slug":"a_ha_5","date":"2020-04-15T13:51:55.000Z","updated":"2020-04-16T10:25:31.713Z","comments":true,"path":"2020/04/15/a_ha_5/","link":"","permalink":"/2020/04/15/a_ha_5/","excerpt":"","text":"1.图的深度优先遍历 #include &lt;stdio.h&gt; int book[101],sum,n,e[101][101]; void dfs(int cur)//cur是当前所在的顶点编号 { int i; printf(&quot;%d &quot;,cur); sum++;//每访问一个顶点sum就加1 if(sum==n) return;//所有顶点都已经访问过则直接退出 for(i=1;i&lt;=n;i++)//从1号顶点到n号顶点依次尝试，看哪些顶点与当前顶点cur有边相连 { //判断当前顶点cur到顶点i是否有边，及顶点i是否已经访问过 if(e[cur][i]==1 &amp;&amp; book[i]==0) { book[i]=1;//标记顶点i已经访问过 dfs(i);//从顶点i再出发继续遍历 } } return; } int main() { int i,j,m,a,b; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); //初始化二维矩阵 for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=n;j++) { if(i==j) e[i][j]=0; else e[i][j]=9999999;//这里假设9999999为正无穷 } } //读入顶点之间的边 for(i=1;i&lt;=m;i++) { scanf(&quot;%d %d&quot;,&amp;a,&amp;b); e[a][b]=1; e[b][a]=1;//这里是无向图，所以也为1 } //从1号城市出发 book[1]=1;//标记1号顶点已经访问 dfs(1);//从1号顶点开始遍历 getchar();getchar(); return 0; } 输入验证：5 51 21 31 52 43 5运行结果：1 2 3 4 5 2.图的广度优先遍历 #include &lt;stdio.h&gt; int main() { int i,j,n,m,a,b,cur,book[101]={0},e[101][101]; int que[10001],head,tail; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); //初始化二维矩阵 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(i==j) e[i][j]=0; else e[i][j]=9999999; //读入顶点之间的边 for(i=1;i&lt;=m;i++) { scanf(&quot;%d %d&quot;,&amp;a,&amp;b); e[a][b]=1; e[b][a]=1; } //队列初始化 head=1; tail=1; //从1号顶点出发，将1号顶点加入队列 que[tail]=1; tail++; book[1]=1;//标记1号顶点已访问 //当前队列不为空的时候循环 while(head&lt;tail) { cur=que[head];//当前正在访问的顶点编号 for(i=1;i&lt;=n;i++)//从1~n依次尝试 { //判断从顶点cur到顶点i是否有边，及顶点i是否已经访问过 if(e[cur][i]==1&amp;&amp;book[i]==0) { //如果从顶点cur到i有边，并且顶点i没有被访问过，则将顶点i入队 que[tail]=i; tail++; book[i]=1;//标记顶点i已访问 } //如果tail大于n,则表明所有顶点都已经被访问过 if(tail&gt;n) { break; } } head++;//注意这地方，千万不能忘记当一个顶点扩展结束后，head++,然后才能继续往下扩展 } for(i=1;i&lt;tail;i++) printf(&quot;%d &quot;,que[i]); getchar();getchar(); return 0; } 输入验证：5 51 21 31 52 43 5运行结果：1 2 3 5 4","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"学习","slug":"学习","permalink":"/tags/学习/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"啊哈！算法之枚举","slug":"a_ha_4","date":"2020-04-15T13:42:03.000Z","updated":"2020-04-15T13:51:19.021Z","comments":true,"path":"2020/04/15/a_ha_4/","link":"","permalink":"/2020/04/15/a_ha_4/","excerpt":"","text":"1.坑爹的奥数 #include &lt;stdio.h&gt; int a[10],book[10],total=0; void dfs(int step)//step表示站在第几个盒子面前 { int i; if(step==10) { //判断是否满足等式□ □ □ + □ □ □ = □ □ □ if(a[1]*100+a[2]*10+a[3]+a[4]*100+a[5]*10+a[6]==a[7]*100+a[8]*10+a[9]) { total++; printf(&quot;%d%d%d+%d%d%d=%d%d%d\\n&quot;,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]); } return;//返回之前的一步（最近调用的地方） } //此时站在第step个盒子面前，应该放哪张牌呢？ //按照1、2、3、、、n的顺序一一尝试 for(i=1;i&lt;=9;i++) { //判断扑克牌i是否还在手上 if(book[i]==0)//book[i]为0表示扑克牌还在手上 { //开始尝试使用扑克牌i a[step]=i;//将扑克牌i放入第step个盒子中 book[i]=1;//将book[i]的值设为1，表示扑克牌i已不在手上 //第step个盒子已经放置好扑克牌，走到下一个盒子面前 dfs(step+1); //这里是非常重要的一步，一定要将刚才尝试的扑克牌收回，才能进行下一次尝试 book[i]=0; } } return; } int main() { dfs(1);//首先站在第一个盒子面前 printf(&quot;total=%d&quot;,total/2); return 0; }","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"学习","slug":"学习","permalink":"/tags/学习/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"啊哈！算法之枚举","slug":"a_ha_3","date":"2020-04-15T13:32:00.000Z","updated":"2020-04-15T13:51:38.341Z","comments":true,"path":"2020/04/15/a_ha_3/","link":"","permalink":"/2020/04/15/a_ha_3/","excerpt":"","text":"1.坑爹的奥数 /*** 填1~9不同的数实现： □ □ □ + □ □ □ = □ □ □ */ #include &lt;stdio.h&gt; int main() { int a[10],i,total=0,book[10],sum; //这里用a[1]~a[9]来表示九个变量 for(a[1]=1;a[1]&lt;=9;a[1]++) for(a[2]=1;a[2]&lt;=9;a[2]++) for(a[3]=1;a[3]&lt;=9;a[3]++) for(a[4]=1;a[4]&lt;=9;a[4]++) for(a[5]=1;a[5]&lt;=9;a[5]++) for(a[6]=1;a[6]&lt;=9;a[6]++) for(a[7]=1;a[7]&lt;=9;a[7]++) for(a[8]=1;a[8]&lt;=9;a[8]++) for(a[9]=1;a[9]&lt;=9;a[9]++) { for(i=1;i&lt;=9;i++) book[i]=0; for(i=1;i&lt;=9;i++) book[a[i]]=1; //统计共出现了多少不同的数 sum=0; for(i=1;i&lt;=9;i++) sum+=book[i]; //如果正好出现了9个不同的数，并且满足等式条件，则输出 if(sum==9&amp;&amp;a[1]*100+a[2]*10+a[3]+a[4]*100+a[5]*10+a[6]==a[7]*100+a[8]*10+a[9]) { total++; printf(&quot;%d%d%d+%d%d%d=%d%d%d\\n&quot;,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]); } } printf(&quot;total=%d&quot;,total/2); return 0; } 此题也可以用深度优先搜索模型实现（转下一章）","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"学习","slug":"学习","permalink":"/tags/学习/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"啊哈！算法之栈、队列、链表","slug":"a_ha_2","date":"2020-04-13T15:03:48.000Z","updated":"2020-04-13T16:08:54.874Z","comments":true,"path":"2020/04/13/a_ha_2/","link":"","permalink":"/2020/04/13/a_ha_2/","excerpt":"","text":"1.解密 QQ 号——队列 #include &lt;stdio.h&gt; int main() { int q[102]={0,6,3,1,7,5,8,9,2,4},head,tail; int i; //初始化队列 head=1; tail=10; //队列中已经有9个元素了，tail指向队尾的后一个位置 while(head&lt;tail) //当队列不为空的时候执行循环 { //打印队首并将队首出队 printf(&quot;%d &quot;,q[head]); head++; //先将新队首的数添加到队尾 q[tail]=q[head]; tail++; //再将队首出队 head++; } getchar();getchar(); return 0; } 最后的输出就是 6 1 5 9 4 7 2 8 3下面这段代码是使用结构体来实现的队列操作: #include &lt;stdio.h&gt; struct queue { int data[100];//队列的主体，用来存储内容 int head;//队首 int tail;//队尾 }; int main() { struct queue q; int i; //初始化队列 q.head=1; q.tail=1; for(i=1;i&lt;=9;i++) { //依次向队列插入9个数 scanf(&quot;%d&quot;,&amp;q.data[q.tail]); q.tail++; } while(q.head&lt;q.tail) //当队列不为空的时候执行循环 { //打印队首并将队首出队 printf(&quot;%d &quot;,q.data[q.head]); q.head++; //先将新队首的数添加到队尾 q.data[q.tail]=q.data[q.head]; q.tail++; //再将队首出队 q.head++; } getchar();getchar(); return 0; } 2.解密回文——栈 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char a[101],s[101]; int i,len,mid,next,top; gets(a); //读入一行字符串 len=strlen(a); //求字符串的长度 mid=len/2-1; //求字符串的中点 top=0;//栈的初始化 //将mid前的字符依次入栈 for(i=0;i&lt;=mid;i++) s[++top]=a[i]; //判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标 if(len%2==0) next=mid+1; else next=mid+2; //开始匹配 for(i=next;i&lt;=len-1;i++) { if(a[i]!=s[top]) break; top--; } //如果top的值为0，则说明栈内所有的字符都被一一匹配了 if(top==0) printf(&quot;YES&quot;); else printf(&quot;NO&quot;); getchar();getchar(); return 0; } 可以输入以下数据进行验证。ahaha运行结果是：YES 3.链表 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型 struct node { int data; struct node *next;//下一个结点的类型也是 struct node，所以这个指针的类型也必须是 struct node * 类型的指针 }; int main() { struct node *head,*p,*q,*t; int i,n,a; scanf(&quot;%d&quot;,&amp;n); head = NULL;//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入n个数 { scanf(&quot;%d&quot;,&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 } //输出链表中的所有数 t=head; while(t!=NULL) { printf(&quot;%d &quot;,t-&gt;data); t=t-&gt;next;//继续下一个结点 } getchar();getchar(); return 0; } 可以输入以下数据进行验证。92 3 5 8 9 10 18 26 32运行结果是：2 3 5 8 9 10 18 26 32 malloc 函数：malloc 函数的作用就是从内存中申请分配指定字节大小的内存空间。上面这行代码就申请了 4 个字节。如果你不知道 int 类型是 4 个字节的，还可以使用 sizeof(int)获取int 类型所占用的字节数，如下：malloc(sizeof(int));现在你已经成功地从内存中申请了 4 个字节的空间来准备存放一个整数，可是如何来对这个空间进行操作呢？这里我们就需要用一个指针来指向这个空间，即存储这个空间的首地址。int p;p=(int )malloc(sizeof(int));需要注意，malloc 函数的返回类型是 void 类型。void 表示?确定类型的指针。在 C和 C++中，void * 类型可以强制转换为任何其他类型的指针。上面代码中我们将其强制转化为整型指针，以便告诉计算机这里的 4 个字节作为一个整体用来存放整数。还记得我们之前遗留了一个问题：指针就是用来存储内存地址的，为什么要分不同类型的指针呢？因为指针变量存储的是一个内存空间的首地址（第一个字节的地址），但是这个空间占用了多少个字节，用来存储什么类型的数，则是由指针的类型来标明的。这样系统才知道应该取多少个连续内存作为一个数据。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型 struct node { int data; struct node *next; }; int main() { struct node *head,*p,*q,*t; int i,n,a; scanf(&quot;%d&quot;,&amp;n); head = NULL;//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入n个数 { scanf(&quot;%d&quot;,&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 } scanf(&quot;%d&quot;,&amp;a);//读入待插入的数 t=head;//从链表头部开始遍历 while(t!=NULL)//当没有到达链表尾部的时候循环 { if(t-&gt;next-&gt;data &gt; a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间 { p=(struct node *)malloc(sizeof(struct node));//动态申请一个空间， 用来存放新增结点 p-&gt;data=a; p-&gt;next=t-&gt;next;//新增结点的后继指针指向当前结点的后继指针所指向的结点 t-&gt;next=p;//当前结点的后继指针指向新增结点 break;//插入完毕退出循环 } t=t-&gt;next;//继续下一个结点 } //输出链表中的所有数 t=head; while(t!=NULL) { printf(&quot;%d &quot;,t-&gt;data); t=t-&gt;next;//继续下一个结点 } getchar();getchar(); return 0; } 可以输入以下数据进行验证。92 3 5 8 9 10 18 26 326运行结果是：2 3 5 6 8 9 10 18 26 32","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"学习","slug":"学习","permalink":"/tags/学习/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"啊哈！算法之排序","slug":"a_ha_1","date":"2020-04-10T12:02:32.000Z","updated":"2020-04-10T14:48:00.491Z","comments":true,"path":"2020/04/10/a_ha_1/","link":"","permalink":"/2020/04/10/a_ha_1/","excerpt":"","text":"1.最快最简单的排序——桶排序 #include &lt;stdio.h&gt; int main() { int book[1001],i,j,t,n; for(i=0;i&lt;=1000;i++) book[i]=0; scanf(&quot;%d&quot;,&amp;n);//输入一个数n，表示接下来有n个数 for(i=1;i&lt;=n;i++)//循环读入n个数，并进行桶排序 { scanf(&quot;%d&quot;,&amp;t); //把每一个数读到变量t中 book[t]++; //进行计数，对编号为t的桶放一个小旗子 } for(i=1000;i&gt;=0;i--) //依次判断编号1000~0的桶 for(j=1;j&lt;=book[i];j++) //出现了几次就将桶的编号打印几次 printf(&quot;%d &quot;,i); getchar();getchar(); //这里的getchar();用来暂停程序，以便查看程序输出的内容 //也可以用system(&quot;pause&quot;);等来代替 return 0; } 可以输入以下数据进行验证。108 100 50 22 15 6 1 1000 999 0运行结果是：1000 999 100 50 22 15 8 6 1 0 2.邻居好说话——冒泡排序 #include &lt;stdio.h&gt; struct student { char name[21]; char score; };//这里创建了一个结构体用来存储姓名和分数 int main() { struct student a[100],t; int i,j,n; scanf(&quot;%d&quot;,&amp;n); //输入一个数n for(i=1;i&lt;=n;i++) //循环读入n个人名和分数 scanf(&quot;%s %d&quot;,a[i].name,&amp;a[i].score); //按分数从高到低进行排序 for(i=1;i&lt;=n-1;i++) { for(j=1;j&lt;=n-i;j++) { if(a[j].score&lt;a[j+1].score)//对分数进行比较 { t=a[j]; a[j]=a[j+1]; a[j+1]=t; } } } for(i=1;i&lt;=n;i++)//输出人名 printf(&quot;%s\\n&quot;,a[i].name); getchar();getchar(); return 0; } 可以输入以下数据进行验证。5huhu 5haha 3xixi 5hengheng 2gaoshou 8运行结果是：gaoshouhuhuxixihahahengheng 3.最常用的排序——快速排序 #include &lt;stdio.h&gt; int a[101],n;//定义全局变量，这两个变量需要在子函数中使用 void quicksort(int left,int right) { int i,j,t,temp; if(left&gt;right) return; temp=a[left]; //temp中存的就是基准数 i=left; j=right; while(i!=j) { //顺序很重要，要先从右往左找 while(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; //再从左往右找 while(a[i]&lt;=temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if(i&lt;j)//当哨兵i和哨兵j没有相遇时 { t=a[i]; a[i]=a[j]; a[j]=t; } } //最终将基准数归位 a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程 } int main() { int i,j,t; //读入数据 scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); quicksort(1,n); //快速排序调用 //输出排序后的结果 for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); getchar();getchar(); return 0; } 可以输入以下数据进行验证。106 1 2 7 9 3 4 5 10 8运行结果是：1 2 3 4 5 6 7 8 9 10","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"},{"name":"学习","slug":"学习","permalink":"/tags/学习/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"My First Blog","slug":"My-First-Blog","date":"2020-03-28T14:36:08.000Z","updated":"2020-04-10T13:05:31.088Z","comments":true,"path":"2020/03/28/My-First-Blog/","link":"","permalink":"/2020/03/28/My-First-Blog/","excerpt":"","text":"今天是我人生中具有历史性的一天，今天我终于搭好了这个博客，今天我辞职了，今天我计划着未来。这将是一个好的开始，我将自动重置，以前的一切清零，不带任何包袱，开启我的未来，并且我会记录下未来“旅途”中的绚烂美景。“路漫漫其修远兮，吾将上下而求索”！","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"感悟","slug":"感悟","permalink":"/tags/感悟/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-28T01:59:01.056Z","updated":"2020-03-28T01:59:01.057Z","comments":true,"path":"2020/03/28/hello-world/","link":"","permalink":"/2020/03/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}